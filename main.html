<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Particles Cursor</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        cursor: none;
      }

      body {
        overflow: hidden;
        background: #000;
        font-family: "Arial", sans-serif;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100vh;
      }

      .cursor {
        position: fixed;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(0, 200, 255, 0.8);
        border-radius: 50%;
        pointer-events: none;
        z-index: 9999;
        transition: transform 0.15s ease;
        box-shadow: 0 0 20px rgba(0, 200, 255, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="cursor"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
      // Particle vertex shader
      const particleVertexShader = `
        uniform float uTime;
        uniform float uPixelRatio;
        attribute float aScale;
        attribute vec3 aRandomness;
        attribute float aDelay;
        
        varying vec3 vColor;
        
        void main() {
          vec4 modelPosition = modelMatrix * vec4(position, 1.0);
          vec4 viewPosition = viewMatrix * modelPosition;
          vec4 projectedPosition = projectionMatrix * viewPosition;
          
          gl_Position = projectedPosition;
          
          // Animate size
          float sizeAnimation = sin((uTime + aDelay) * 3.0) * 0.5 + 0.5;
          gl_PointSize = aScale * uPixelRatio * (2.0 + sizeAnimation * 2.0);
          gl_PointSize *= (300.0 / -viewPosition.z);
          
          // Color variation based on position and time
          vColor = vec3(
            0.0 + aRandomness.x * 0.3,
            0.5 + aRandomness.y * 0.5,
            1.0
          );
        }
      `;

      // Particle fragment shader
      const particleFragmentShader = `
        varying vec3 vColor;
        
        void main() {
          // Create circular particles with soft edges
          float dist = distance(gl_PointCoord, vec2(0.5));
          float alpha = smoothstep(0.5, 0.0, dist);
          
          // Add glow effect
          float glow = smoothstep(0.5, 0.2, dist);
          
          vec3 finalColor = vColor + glow * 0.5;
          
          gl_FragColor = vec4(finalColor, alpha * 0.8);
        }
      `;

      // FBO Vertex Shader for trail
      const fboVertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      // FBO Fragment Shader for trail
      const fboFragmentShader = `
        uniform sampler2D uTexture;
        uniform vec2 uMouse;
        uniform float uTime;
        uniform vec2 uResolution;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(uTexture, vUv);
          
          // Decay
          color *= 0.96;
          
          // Add particles at mouse position
          vec2 pixelPos = vUv * uResolution;
          float dist = distance(pixelPos, uMouse);
          
          float radius = 30.0;
          float intensity = smoothstep(radius, 0.0, dist);
          
          // Cyan/blue color
          vec3 particleColor = vec3(0.0, 0.6 + sin(uTime * 3.0) * 0.2, 1.0);
          color.rgb += particleColor * intensity * 0.6;
          
          gl_FragColor = vec4(color.rgb, 1.0);
        }
      `;

      // Display shader
      const displayFragmentShader = `
        uniform sampler2D uTexture;
        uniform float uTime;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(uTexture, vUv);
          
          // Add glow
          float offset = 0.003;
          vec4 glow = vec4(0.0);
          
          for(float x = -2.0; x <= 2.0; x += 1.0) {
            for(float y = -2.0; y <= 2.0; y += 1.0) {
              vec2 offsetUv = vUv + vec2(x, y) * offset;
              glow += texture2D(uTexture, offsetUv);
            }
          }
          
          glow /= 25.0;
          
          vec3 finalColor = color.rgb + glow.rgb * 1.2;
          finalColor = pow(finalColor, vec3(0.9));
          
          gl_FragColor = vec4(finalColor, 1.0);
        }
      `;

      // Scene setup
      let scene, camera, renderer;
      let particles, particlesMaterial;
      let fboScene, fboCamera, fboMaterial, displayMaterial;
      let renderTargetA, renderTargetB;
      let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      let targetMouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
      let mouseHistory = [];
      const maxHistoryLength = 30;

      function init() {
        // Main scene
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 3;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Create particles
        createParticles();

        // FBO Setup
        setupFBO();

        // Event listeners
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("resize", onResize);

        // Start animation
        animate();
      }

      function createParticles() {
        const particlesCount = 2000;
        const positions = new Float32Array(particlesCount * 3);
        const scales = new Float32Array(particlesCount);
        const randomness = new Float32Array(particlesCount * 3);
        const delays = new Float32Array(particlesCount);

        for (let i = 0; i < particlesCount; i++) {
          const i3 = i * 3;

          // Create particles in a sphere around origin
          const radius = Math.random() * 0.5;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.random() * Math.PI;

          positions[i3] = 0;
          positions[i3 + 1] = 0;
          positions[i3 + 2] = 0;

          scales[i] = Math.random() * 0.5 + 0.5;
          randomness[i3] = Math.random();
          randomness[i3 + 1] = Math.random();
          randomness[i3 + 2] = Math.random();
          delays[i] = Math.random() * Math.PI * 2;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("aScale", new THREE.BufferAttribute(scales, 1));
        geometry.setAttribute(
          "aRandomness",
          new THREE.BufferAttribute(randomness, 3)
        );
        geometry.setAttribute("aDelay", new THREE.BufferAttribute(delays, 1));

        particlesMaterial = new THREE.ShaderMaterial({
          vertexShader: particleVertexShader,
          fragmentShader: particleFragmentShader,
          uniforms: {
            uTime: { value: 0 },
            uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
          },
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        });

        particles = new THREE.Points(geometry, particlesMaterial);
        scene.add(particles);
      }

      function setupFBO() {
        fboScene = new THREE.Scene();
        fboCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const rtOptions = {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBAFormat,
        };

        renderTargetA = new THREE.WebGLRenderTarget(
          window.innerWidth,
          window.innerHeight,
          rtOptions
        );
        renderTargetB = new THREE.WebGLRenderTarget(
          window.innerWidth,
          window.innerHeight,
          rtOptions
        );

        fboMaterial = new THREE.ShaderMaterial({
          vertexShader: fboVertexShader,
          fragmentShader: fboFragmentShader,
          uniforms: {
            uTexture: { value: null },
            uMouse: { value: new THREE.Vector2() },
            uTime: { value: 0 },
            uResolution: {
              value: new THREE.Vector2(window.innerWidth, window.innerHeight),
            },
          },
        });

        displayMaterial = new THREE.ShaderMaterial({
          vertexShader: fboVertexShader,
          fragmentShader: displayFragmentShader,
          uniforms: {
            uTexture: { value: null },
            uTime: { value: 0 },
          },
        });

        const planeGeometry = new THREE.PlaneGeometry(2, 2);
        const fboMesh = new THREE.Mesh(planeGeometry, fboMaterial);
        fboScene.add(fboMesh);
      }

      function onMouseMove(event) {
        targetMouse.x = event.clientX;
        targetMouse.y = event.clientY;

        // Update cursor
        const cursor = document.querySelector(".cursor");
        gsap.to(cursor, {
          x: event.clientX - 10,
          y: event.clientY - 10,
          duration: 0.3,
          ease: "power2.out",
        });
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderTargetA.setSize(window.innerWidth, window.innerHeight);
        renderTargetB.setSize(window.innerWidth, window.innerHeight);

        fboMaterial.uniforms.uResolution.value.set(
          window.innerWidth,
          window.innerHeight
        );
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now() * 0.001;

        // Smooth mouse movement
        mouse.x += (targetMouse.x - mouse.x) * 0.05;
        mouse.y += (targetMouse.y - mouse.y) * 0.05;

        // Add to history
        mouseHistory.push({ x: mouse.x, y: mouse.y });
        if (mouseHistory.length > maxHistoryLength) {
          mouseHistory.shift();
        }

        // Update particle positions based on mouse history
        const positions = particles.geometry.attributes.position.array;
        const particlesPerPoint = Math.floor(
          positions.length / 3 / maxHistoryLength
        );

        for (let i = 0; i < mouseHistory.length; i++) {
          const historyPoint = mouseHistory[i];
          const normalizedX = (historyPoint.x / window.innerWidth) * 2 - 1;
          const normalizedY = -(historyPoint.y / window.innerHeight) * 2 + 1;

          for (let j = 0; j < particlesPerPoint; j++) {
            const index = (i * particlesPerPoint + j) * 3;
            if (index < positions.length) {
              const angle = (j / particlesPerPoint) * Math.PI * 2;
              const spread = (i / maxHistoryLength) * 0.3;

              positions[index] =
                normalizedX * camera.aspect * 1.5 +
                Math.cos(angle) * spread * Math.sin(time + i);
              positions[index + 1] =
                normalizedY * 1.5 +
                Math.sin(angle) * spread * Math.cos(time + i);
              positions[index + 2] = -(i / maxHistoryLength) * 2;
            }
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particlesMaterial.uniforms.uTime.value = time;

        // FBO rendering
        fboMaterial.uniforms.uTime.value = time;
        fboMaterial.uniforms.uMouse.value.set(
          mouse.x,
          window.innerHeight - mouse.y
        );
        fboMaterial.uniforms.uTexture.value = renderTargetB.texture;

        renderer.setRenderTarget(renderTargetA);
        renderer.render(fboScene, fboCamera);

        // Swap targets
        const temp = renderTargetA;
        renderTargetA = renderTargetB;
        renderTargetB = temp;

        // Render main scene with FBO background
        renderer.setRenderTarget(null);
        renderer.clear();

        // Draw FBO result first
        displayMaterial.uniforms.uTexture.value = renderTargetB.texture;
        displayMaterial.uniforms.uTime.value = time;
        const plane = new THREE.Mesh(
          new THREE.PlaneGeometry(2, 2),
          displayMaterial
        );
        plane.position.z = -1;

        const tempScene = new THREE.Scene();
        const tempCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
        tempScene.add(plane);
        renderer.render(tempScene, tempCamera);

        // Then render particles
        renderer.render(scene, camera);
      }

      // Initialize
      init();
    </script>
  </body>
</html>
